# Лабораторная работа 2

## Тема: Работа с коллекциями

## Цель работы

Проанализировать и сравнить производительность операций над коллекциями: `List<T>`, `LinkedList<T>`, `Queue<T>`, `Stack<T>` и `ImmutableList<T>`.

## Структура проекта

```
lab2/
├── Program.cs                    # Главная программа
├── PerformanceBenchmark.cs       # Класс для замеров производительности
├── README.md                     # Документация
└── tests/                        # Папка с тестами
    ├── ImmutableListTests.cs     # Тесты для ImmutableList<T>
    ├── LinkedListTests.cs        # Тесты для LinkedList<T>
    ├── ListTests.cs              # Тесты для List<T>
    ├── QueueTests.cs             # Тесты для Queue<T>
    └── StackTests.cs             # Тесты для Stack<T>
```

## Описание подхода к реализации замеров

### Методология

1. **Объем данных**: Для получения релевантных результатов используются коллекции размером 100 000 элементов.

2. **Процесс измерения**:
   - Перед замером выполняется прогрев (3 итерации) для "прогрева" JIT-компилятора и кэшей процессора
   - Каждая операция выполняется 5 раз
   - Результаты усредняются для получения более стабильных данных
   - Перед каждой итерацией выполняется сборка мусора (GC.Collect()) для минимизации влияния предыдущих операций

3. **Инструменты измерения**:
   - `System.Diagnostics.Stopwatch` для точного измерения времени выполнения
   - Измеряется среднее, минимальное и максимальное время выполнения

4. **Тестируемые операции**:
   - Добавление элементов (в конец, в начало, в середину)
   - Удаление элементов (из начала, из конца, из середины)
   - Поиск элемента по значению
   - Получение элемента по индексу (если применимо)

### Автоматизированное тестирование

Для проверки корректности операций написаны автоматизированные тесты с использованием xUnit:
- Тесты детерминированы и воспроизводимы
- Используются одинаковые входные данные
- Проверяются ожидаемые результаты
- Отдельные тестовые классы для каждой коллекции

## Результаты замеров

### Ожидаемые результаты

#### Добавление в конец
- **List<T>**: O(1) амортизированное время - быстрое
- **LinkedList<T>**: O(1) - очень быстрое
- **Queue<T>**: O(1) - быстрое
- **Stack<T>**: O(1) - быстрое
- **ImmutableList<T>**: O(log n) - медленнее из-за неизменяемости

#### Добавление в начало
- **List<T>**: O(n) - медленное, требуется сдвиг всех элементов
- **LinkedList<T>**: O(1) - очень быстрое
- **Queue<T>**: Не поддерживается напрямую
- **Stack<T>**: Не поддерживается (FIFO принцип)
- **ImmutableList<T>**: O(log n) - медленнее обычного List

#### Добавление в середину
- **List<T>**: O(n) - требуется сдвиг элементов
- **LinkedList<T>**: O(1) после нахождения позиции, но поиск O(n)
- **ImmutableList<T>**: O(log n) - медленнее обычного List

#### Удаление из начала
- **List<T>**: O(n) - требуется сдвиг всех элементов
- **LinkedList<T>**: O(1) - очень быстрое
- **Queue<T>**: O(1) - быстрое (основная операция)
- **ImmutableList<T>**: O(log n) - медленнее обычного List

#### Удаление из конца
- **List<T>**: O(1) - быстрое
- **LinkedList<T>**: O(1) - быстрое
- **Stack<T>**: O(1) - быстрое (основная операция)
- **ImmutableList<T>**: O(log n) - медленнее обычного List

#### Поиск по значению
- **List<T>**: O(n) - линейный поиск
- **LinkedList<T>**: O(n) - линейный поиск
- **Queue<T>**: O(n) - линейный поиск
- **Stack<T>**: O(n) - линейный поиск
- **ImmutableList<T>**: O(n) - линейный поиск

#### Получение по индексу
- **List<T>**: O(1) - прямое обращение по индексу
- **LinkedList<T>**: O(n) - требуется проход по списку
- **ImmutableList<T>**: O(1) - прямое обращение по индексу

## Анализ преимуществ и недостатков коллекций

### List<T>

**Преимущества**:
- Быстрый доступ по индексу O(1)
- Эффективное добавление в конец O(1) амортизированное
- Эффективное удаление с конца O(1)
- Хорошая локальность данных в памяти
- Предсказуемая производительность

**Недостатки**:
- Медленное добавление/удаление в начале O(n)
- Медленное добавление/удаление в середине O(n)
- Может требовать выделения дополнительной памяти при росте

**Рекомендации по использованию**:
- Когда нужен быстрый доступ по индексу
- Когда большинство операций - добавление/удаление в конец
- Когда известен примерный размер коллекции (можно задать Capacity)
- Для большинства повседневных задач

### LinkedList<T>

**Преимущества**:
- Очень быстрое добавление/удаление в начале O(1)
- Очень быстрое добавление/удаление в конце O(1)
- Эффективное добавление/удаление в середине O(1) после нахождения позиции
- Не требует перераспределения памяти

**Недостатки**:
- Медленный доступ по индексу O(n)
- Требует больше памяти (хранение ссылок)
- Плохая локальность данных (элементы разбросаны по памяти)
- Поиск элемента O(n)

**Рекомендации по использованию**:
- Когда часто происходит вставка/удаление в начале или середине
- Когда не нужен доступ по индексу
- Когда важна эффективность операций вставки/удаления

### Queue<T>

**Преимущества**:
- Оптимизирована для FIFO (First In, First Out)
- Эффективная операция Enqueue O(1)
- Эффективная операция Dequeue O(1)
- Простой интерфейс для очередей

**Недостатки**:
- Ограниченная функциональность (только FIFO операции)
- Нет прямого доступа к элементам по индексу
- Не поддерживает операции в середине коллекции

**Рекомендации по использованию**:
- Для реализации очередей задач
- Обработка событий в порядке поступления
- BFS алгоритмы
- Буферизация данных

### Stack<T>

**Преимущества**:
- Оптимизирована для LIFO (Last In, First Out)
- Эффективная операция Push O(1)
- Эффективная операция Pop O(1)
- Простой интерфейс для стеков

**Недостатки**:
- Ограниченная функциональность (только LIFO операции)
- Нет прямого доступа к элементам по индексу
- Не поддерживает операции в середине коллекции

**Рекомендации по использованию**:
- Для реализации стеков
- Рекурсивные алгоритмы (замена рекурсии)
- Обработка выражений (обратная польская нотация)
- Undo/Redo функциональность

### ImmutableList<T>

**Преимущества**:
- Неизменяемость - безопасность в многопоточном коде
- Возможность безопасного совместного использования данных
- Функциональное программирование
- Возможность отката изменений

**Недостатки**:
- Более медленные операции из-за создания новых экземпляров
- Больший расход памяти (структуры данных переиспользуются через sharing)
- Более сложная реализация

**Рекомендации по использованию**:
- Многопоточное программирование
- Функциональное программирование
- Когда нужна история изменений
- Когда безопасность данных критична

## Рекомендации по применению коллекций на основе производительности

### Общие рекомендации

1. **Предварительное выделение Capacity для List<T>**:
   - Если известен примерный размер коллекции, задавайте Capacity при создании
   - Это уменьшает количество перераспределений памяти
   - Особенно важно при работе с большими коллекциями

2. **Выбор коллекции по частоте операций**:
   - Анализируйте, какие операции выполняются чаще всего
   - Оптимизируйте под наиболее частые операции
   - Избегайте коллекций с плохой производительностью для частых операций

3. **Влияние на Garbage Collector**:
   - List<T> с частыми перераспределениями создает больше мусора
   - LinkedList<T> создает больше объектов (узлы списка)
   - ImmutableList<T> может эффективно переиспользовать структуры
   - Учитывайте частоту GC при выборе коллекции

### Специфические сценарии

1. **Частые вставки в начало**: Используйте `LinkedList<T>` или `Queue<T>`
2. **Частые вставки в конец**: Используйте `List<T>` с заданным Capacity
3. **Доступ по индексу**: Используйте `List<T>`
4. **Очередь задач**: Используйте `Queue<T>`
5. **Стек вызовов**: Используйте `Stack<T>`
6. **Многопоточность**: Рассмотрите `ImmutableList<T>`